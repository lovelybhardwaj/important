# -*- coding: utf-8 -*-
"""east.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vXRLNhalcfZN6JcwUqq7fARfuoFS59tx
"""
import os
import numpy as np
import cv2
from imutils.object_detection import non_max_suppression
import pytesseract
from matplotlib import pyplot as plt
import tensorflow.compat.v1 as tf
from google.protobuf import text_format
from PIL import Image
import shutil



class EAST():
    def __init__(self,image):
        self.args = {"east":r"C:\Users\Lovely Bhardwaj\OneDrive\Desktop\models\file\content\ALL_FILES\frozen_east_text_detection.pb", "min_confidence":0.5, "width":320, "height":320}
        self.image = cv2.imread(image)
        self.newH = self.args['height']
        self.newW = self.args['width']
        self.min_confidence = self.args['min_confidence']
        self.orig = self.image.copy()
        self.forward(self.args)

    def func_1(self):
        orig = self.orig

        image = cv2.resize(self.image, (self.newW, self.newH))
        (H, W) = image.shape[:2]

        blob = cv2.dnn.blobFromImage(image, 1.0, (W, H), (123.68, 116.78, 103.94), swapRB=True, crop=False)
        net = cv2.dnn.readNet(self.args["east"])
        layerNames = ["feature_fusion/Conv_7/Sigmoid", "feature_fusion/concat_3"]
        net.setInput(blob)
        prob_score, geo = net.forward(layerNames)
        return prob_score, geo

    def prediction(self,prob_score,geo):
        (numR, numC) = prob_score.shape[2:4]
        boxes = []
        confidence_val = []

        for y in range(0, numR):
            scoresData = prob_score[0, 0, y]
            x0 = geo[0, 0, y]
            x1 = geo[0, 1, y]
            x2 = geo[0, 2, y]
            x3 = geo[0, 3, y]
            anglesData = geo[0, 4, y]

            # loop over the number of columns
            for i in range(0, numC):
                if scoresData[i] < self.min_confidence:
                    continue

                (offX, offY) = (i * 4.0, y * 4.0)

                # extracting the rotation angle for the prediction and computing the sine and cosine
                angle = anglesData[i]
                cos = np.cos(angle)
                sin = np.sin(angle)

                # using the geo volume to get the dimensions of the bounding box
                h = x0[i] + x2[i]
                w = x1[i] + x3[i]

                # compute start and end for the text pred bbox
                endX = int(offX + (cos * x1[i]) + (sin * x2[i]))
                endY = int(offY - (sin * x1[i]) + (cos * x2[i]))
                startX = int(endX - w)
                startY = int(endY - h)

                boxes.append((startX, startY, endX, endY))
                confidence_val.append(scoresData[i])
                (boxes, confidence_val)
        return (boxes, confidence_val)

    def func2(self,boxes):
        results = []
        orig = self.orig
        (origH, origW) = orig.shape[:2]

        rH = origH / float(self.newH)
        rW = origW / float(self.newW)
          # loop over the bounding boxes to find the coordinate of bounding boxes
        for (startX, startY, endX, endY) in boxes:

            startX = int(startX * rW)
            startY = int(startY * rH)
            endX = int(endX * rW)
            endY = int(endY * rH)
            #extract the region of interest
            r = orig[startY:endY, startX:endX]
            #configuration setting to convert image to string.
            configuration = ("-l eng --oem 1 --psm 8")
              ##This will recognize the text from the image of bounding box
            text = pytesseract.image_to_string(r, config=configuration)

            # append bbox coordinate and associated text to the list of results
            results.append(((startX, startY, endX, endY), text))

            return results

    def save_imgs(self,results):
      for i, ((startX, startY, endX, endY), text) in enumerate(results):
        # Crop the image using the bounding box coordinates
        orig_image = self.orig
        cropped_image = orig_image[startY:endY, startX:endX]

        # Create a PIL image from the cropped image array
        pil_image = Image.fromarray(cropped_image)

        #Create ids for _getitem_() function
        id = []
        id = id.append(i+1)
        # Save the cropped image with a unique name
        save_path = r"C:\Users\Lovely Bhardwaj\OneDrive\Desktop\models\file\content\ALL_FILES\crop_images\Cropped_Images_{i+1}.jpg"
        pil_image.save(save_path)

    def forward(self,args):
        prob_score,geo = self.func_1()
        (boxes,confidence_val) = self.prediction(prob_score,geo)
        boxes = non_max_suppression(np.array(boxes), probs=confidence_val)
        for i in range(boxes.shape[0]):
          if(boxes[i,0]>=4):
            boxes[i,0]=boxes[i,0]-4
          if(boxes[i,1]>=4):
            boxes[i,1]=boxes[i,1]-4
          if(boxes[i,2]<=boxes.max()-4):
            boxes[i,2]=boxes[i,2]+4
          if(boxes[i,3]<=boxes.max()-4):
            boxes[i,3]=boxes[i,3]+4
        results = self.func2(boxes)
        orig_image = self.image.copy()
        pil_image = Image.fromarray(orig_image)

          # Save the image as JPEG
        save_path = "BoxImage.jpg"
        pil_image.save(save_path, "JPEG")

        folder_path = r"C:\Users\Lovely Bhardwaj\OneDrive\Desktop\models\file\content\ALL_FILES\crop_images"
        if os.path.isdir(folder_path):
          shutil.rmtree(folder_path)

            
        os.makedirs(folder_path)

              # Check if the folder was created
        if os.path.exists(folder_path):
          print("Cropped_Images folder created successfully.")
        else:
          print("Failed to create the Cropped_Images folder.")

        self.save_imgs(results)



        return print('Done')